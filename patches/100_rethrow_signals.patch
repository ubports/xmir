--- a/hw/dmx/dmxinit.c
+++ b/hw/dmx/dmxinit.c
@@ -864,7 +864,7 @@
  * We must ensure that backend and console state is restored in the
  * event the server shutdown wasn't clean. */
 void
-AbortDDX(enum ExitCode error)
+SigAbortDDX(int signo, enum ExitCode error)
 {
     int i;
 
@@ -884,6 +884,12 @@
 }
 #endif
 
+void
+AbortDDX(enum ExitCode error)
+{
+    SigAbortDDX(0, error);
+}
+
 /** This function is called in Xserver/dix/main.c from \a main() when
  * dispatchException & DE_TERMINATE (which is the only way to exit the
  * main loop without an interruption. */
--- a/hw/kdrive/src/kdrive.c
+++ b/hw/kdrive/src/kdrive.c
@@ -222,7 +222,7 @@
 }
 
 void
-AbortDDX(enum ExitCode error)
+SigAbortDDX(int signo, enum ExitCode error)
 {
     KdDisableScreens();
     if (kdOsFuncs) {
@@ -237,6 +237,11 @@
         OsAbort();
 }
 
+AbortDDX(enum ExitCode error)
+{
+    SigAbortDDX(0, error);
+}
+
 void
 ddxGiveUp(enum ExitCode error)
 {
--- a/hw/vfb/InitOutput.c
+++ b/hw/vfb/InitOutput.c
@@ -201,11 +201,17 @@
 }
 
 void
-AbortDDX(enum ExitCode error)
+SigAbortDDX(int signo, enum ExitCode error)
 {
     ddxGiveUp(error);
 }
 
+void
+AbortDDX(enum ExitCode error)
+{
+    SigAbortDDX(0, error);
+}
+
 #ifdef __APPLE__
 void
 DarwinHandleGUI(int argc, char *argv[])
--- a/hw/xfree86/common/xf86Events.c
+++ b/hw/xfree86/common/xf86Events.c
@@ -348,6 +348,8 @@
 int
 xf86SigWrapper(int signo)
 {
+    static Bool beenhere = FALSE;
+
     if ((signo == SIGILL) && xf86SigIllHandler) {
         (*xf86SigIllHandler) ();
         return 0;               /* continue */
--- a/hw/xfree86/common/xf86Init.c
+++ b/hw/xfree86/common/xf86Init.c
@@ -967,14 +967,17 @@
 }
 
 /*
- * ddxGiveUp --
+ * ddxSigGiveUp --
  *      Device dependent cleanup. Called by by dix before normal server death.
  *      For SYSV386 we must switch the terminal back to normal mode. No error-
  *      checking here, since there should be restored as much as possible.
+ *
+ *      If a non-zero signo is passed, re-raise that signal rather than
+ *      calling abort().
  */
 
 void
-ddxGiveUp(enum ExitCode error)
+ddxSigGiveUp(int signo, enum ExitCode error)
 {
     int i;
 
@@ -1001,22 +1004,46 @@
     if (xorgHWOpenConsole)
         xf86CloseConsole();
 
+    ErrorF(" ddxSigGiveUp: Closing log\n");
+
     xf86CloseLog(error);
 
     /* If an unexpected signal was caught, dump a core for debugging */
-    if (xf86Info.caughtSignal)
-        OsAbort();
+    if (xf86Info.caughtSignal) {
+        if (signo != 0) {
+            raise(signo);
+        }
+        else {
+            OsAbort();
+        }
+    }
 }
 
 /*
- * AbortDDX --
+ * ddxGiveUp --
+ *      Device dependent cleanup. Called by by dix before normal server death.
+ *      For SYSV386 we must switch the terminal back to normal mode. No error-
+ *      checking here, since there should be restored as much as possible.
+ */
+
+void
+ddxGiveUp(enum ExitCode error)
+{
+    ddxSigGiveUp(0, error);
+}
+
+/*
+ * SigAbortDDX --
  *      DDX - specific abort routine.  Called by AbortServer(). The attempt is
  *      made to restore all original setting of the displays. Also all devices
  *      are closed.
+ *
+ *      If a non-zero signo is passed, re-raise that signal rather than calling
+ *      abort()
  */
 
 void
-AbortDDX(enum ExitCode error)
+SigAbortDDX(int signo, enum ExitCode error)
 {
     int i;
 
@@ -1049,7 +1076,20 @@
      * This is needed for an abnormal server exit, since the normal exit stuff
      * MUST also be performed (i.e. the vt must be left in a defined state)
      */
-    ddxGiveUp(error);
+    ddxSigGiveUp(signo, error);
+}
+
+/*
+ * AbortDDX --
+ *      DDX - specific abort routine.  The attempt is made to restore
+ *      all original setting of the displays. Also all devices are
+ *      closed.
+ */
+
+void
+AbortDDX(enum ExitCode error)
+{
+    SigAbortDDX(0, error);
 }
 
 void
--- a/hw/xnest/Init.c
+++ b/hw/xnest/Init.c
@@ -115,12 +115,18 @@
  * DDX - specific abort routine.  Called by AbortServer().
  */
 void
-AbortDDX(enum ExitCode error)
+SigAbortDDX(int signo, enum ExitCode error)
 {
     xnestDoFullGeneration = True;
     xnestCloseDisplay();
 }
 
+void
+AbortDDX(enum ExitCode error)
+{
+    SigAbortDDX(0, error);
+}
+
 /* Called by GiveUp(). */
 void
 ddxGiveUp(enum ExitCode error)
--- a/hw/xquartz/darwin.c
+++ b/hw/xquartz/darwin.c
@@ -853,15 +853,22 @@
 }
 
 /*
- * AbortDDX --
+ * [Sig]AbortDDX --
  *      DDX - specific abort routine.  Called by AbortServer(). The attempt is
  *      made to restore all original setting of the displays. Also all devices
  *      are closed.
  */
 _X_NORETURN
 void
-AbortDDX(enum ExitCode error)
+SigAbortDDX(int signo, enum ExitCode error)
 {
     ErrorF("   AbortDDX\n");
     OsAbort();
 }
+
+_X_NORETURN
+void
+AbortDDX(enum ExitCode error)
+{
+    SigAbortDDX(0, error);
+}
\ No newline at end of file
--- a/hw/xwin/InitOutput.c
+++ b/hw/xwin/InitOutput.c
@@ -233,7 +233,7 @@
 
 /* See Porting Layer Definition - p. 57 */
 void
-AbortDDX(enum ExitCode error)
+SigAbortDDX(int signo, enum ExitCode error)
 {
 #if CYGDEBUG
     winDebug("AbortDDX\n");
@@ -241,6 +241,12 @@
     ddxGiveUp(error);
 }
 
+void
+AbortDDX(enum ExitCode error)
+{
+    SigAbortDDX(0, error);
+}
+
 #ifdef __CYGWIN__
 /* hasmntopt is currently not implemented for cygwin */
 static const char *
--- a/include/os.h
+++ b/include/os.h
@@ -521,8 +521,12 @@
 };
 
 extern _X_EXPORT void
+SigAbortDDX(int signo, enum ExitCode error);
+extern _X_EXPORT void
 AbortDDX(enum ExitCode error);
 extern _X_EXPORT void
+ddxSigGiveUp(int signo, enum ExitCode error);
+extern _X_EXPORT void
 ddxGiveUp(enum ExitCode error);
 extern _X_EXPORT int
 TimeSinceLastInputEvent(void);
--- a/os/log.c
+++ b/os/log.c
@@ -86,6 +86,8 @@
 #include <stdarg.h>
 #include <stdlib.h>             /* for malloc() */
 
+#include <signal.h>             /* for raise() */
+
 #include "input.h"
 #include "site.h"
 #include "opaque.h"
@@ -463,9 +465,12 @@
 void
 AbortServer(void)
     _X_NORETURN;
+void
+SigAbortServer(int signo)
+    _X_NORETURN;
 
 void
-AbortServer(void)
+SigAbortServer(int signo)
 {
 #ifdef XF86BIGFONT
     XF86BigfontCleanup();
@@ -473,11 +478,23 @@
     CloseWellKnownConnections();
     OsCleanup(TRUE);
     CloseDownDevices();
-    AbortDDX(EXIT_ERR_ABORT);
+    SigAbortDDX(signo, EXIT_ERR_ABORT);
     fflush(stderr);
-    if (CoreDump)
-        OsAbort();
-    exit(1);
+    if (CoreDump) {
+        if (signo != 0)
+            raise(signo);
+        else
+            OsAbort();
+    }
+    else {
+        exit(1);
+    }
+}
+
+void
+AbortServer()
+{
+    SigAbortServer(0);
 }
 
 #define AUDIT_PREFIX "AUDIT: %s: %ld: "
@@ -580,6 +597,27 @@
 }
 
 void
+FatalSignal(int signo)
+{
+    static Bool beenhere = FALSE;
+
+    if (beenhere)
+        ErrorF("\nFatalSignal re-entered, aborting\n");
+    else
+        ErrorF("\nCaught signal %d (%s). Server aborting\n",
+               signo, strsignal(signo));
+
+    if (!beenhere)
+        OsVendorFatalError();
+    if (!beenhere) {
+        beenhere = TRUE;
+        SigAbortServer(signo);
+    }
+    else
+        abort();
+ /*NOTREACHED*/}
+
+void
 FatalError(const char *f, ...)
 {
     va_list args;
--- a/os/osinit.c
+++ b/os/osinit.c
@@ -138,13 +138,13 @@
         case SIGBUS:
         case SIGILL:
         case SIGFPE:
+            signal(signo, SIG_DFL);
             ErrorF("%s at address %p\n", strsignal(signo), sip->si_addr);
         }
     }
 #endif
 
-    FatalError("Caught signal %d (%s). Server aborting\n",
-               signo, strsignal(signo));
+    FatalSignal(signo);
 }
 
 void
