diff --git a/configure.ac b/configure.ac
index c6ecba4..07d02d0 100644
--- a/configure.ac
+++ b/configure.ac
@@ -635,6 +635,7 @@ AC_ARG_ENABLE(windowswm,      AS_HELP_STRING([--enable-windowswm], [Build XWin w
 AC_ARG_ENABLE(libdrm,         AS_HELP_STRING([--enable-libdrm], [Build Xorg with libdrm support (default: enabled)]), [DRM=$enableval],[DRM=yes])
 AC_ARG_ENABLE(clientids,      AS_HELP_STRING([--disable-clientids], [Build Xorg with client ID tracking (default: enabled)]), [CLIENTIDS=$enableval], [CLIENTIDS=yes])
 AC_ARG_ENABLE(pciaccess, AS_HELP_STRING([--enable-pciaccess], [Build Xorg with pciaccess library (default: enabled)]), [PCI=$enableval], [PCI=yes])
+AC_ARG_ENABLE(xmir,           AS_HELP_STRING([--enable-xmir], [Build support for nesting in Mir (default: auto)]), [XMIR=$enableval], [XMIR=auto])
 
 dnl DDXes.
 AC_ARG_ENABLE(xorg,    	      AS_HELP_STRING([--enable-xorg], [Build Xorg server (default: auto)]), [XORG=$enableval], [XORG=auto])
@@ -1148,6 +1149,15 @@ if test "x$XINERAMA" = xyes; then
 	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES $XINERAMAPROTO"
 fi
 
+if test "x$XMIR" != xno; then
+	PKG_CHECK_MODULES([XMIR], [mirclient atomic_ops], [XMIR=yes], [XMIR=no])
+	AC_SUBST([XMIR_LIBS])
+        AC_SUBST([XMIR_CFLAGS])
+        AC_DEFINE(XMIR, 1, [Support Mir nested mode])
+	SDK_REQUIRED_MODULES="$SDK_REQUIRED_MODULES mirclient atomic_ops"
+fi	      
+AM_CONDITIONAL(XMIR, [test "x$XMIR" = xyes])
+
 AM_CONDITIONAL(XACE, [test "x$XACE" = xyes])
 if test "x$XACE" = xyes; then
 	AC_DEFINE(XACE, 1, [Build X-ACE extension])
@@ -2299,6 +2309,7 @@ hw/xfree86/utils/Makefile
 hw/xfree86/utils/man/Makefile
 hw/xfree86/utils/cvt/Makefile
 hw/xfree86/utils/gtf/Makefile
+hw/xfree86/xmir/Makefile
 hw/dmx/config/Makefile
 hw/dmx/config/man/Makefile
 hw/dmx/doc/Makefile
diff --git a/hw/xfree86/Makefile.am b/hw/xfree86/Makefile.am
index c3899b5..6821198 100644
--- a/hw/xfree86/Makefile.am
+++ b/hw/xfree86/Makefile.am
@@ -25,15 +25,20 @@ if INT10MODULE
 INT10_SUBDIR = int10
 endif
 
+if XMIR
+XMIR_SUBDIR = xmir
+endif
+
 SUBDIRS = common ddc x86emu $(INT10_SUBDIR) os-support parser \
 	  ramdac $(VGAHW_SUBDIR) loader modes $(DRI_SUBDIR) \
 	  $(DRI2_SUBDIR) . $(VBE_SUBDIR) i2c dixmods \
-	  fbdevhw shadowfb exa $(XF86UTILS_SUBDIR) doc man
+	  fbdevhw shadowfb exa $(XF86UTILS_SUBDIR) doc man \
+	  $(XMIR_SUBDIR)
 
 DIST_SUBDIRS = common ddc i2c x86emu int10 fbdevhw os-support \
                parser ramdac shadowfb vbe vgahw \
                loader dixmods dri dri2 exa modes \
-	       utils doc man
+	       utils doc man xmir
 
 bin_PROGRAMS = Xorg
 nodist_Xorg_SOURCES = sdksyms.c
diff --git a/hw/xfree86/common/xf86Config.c b/hw/xfree86/common/xf86Config.c
index 74d5ed3..538ba4b 100644
--- a/hw/xfree86/common/xf86Config.c
+++ b/hw/xfree86/common/xf86Config.c
@@ -118,6 +118,7 @@ static ModuleDefault ModuleDefaults[] = {
     {.name = "fb",.toLoad = TRUE,.load_opt = NULL},
     {.name = "shadow",.toLoad = TRUE,.load_opt = NULL},
 #endif
+    {.name = "xmir", .toLoad = FALSE, .load_opt = NULL},
     {.name = NULL,.toLoad = FALSE,.load_opt = NULL}
 };
 
@@ -260,6 +261,17 @@ xf86ModulelistFromConfig(pointer **optlist)
         return NULL;
     }
 
+    /*
+     * Set the xmir module to autoload if requested.
+     */
+    if (xorgMir) {
+        for (i=0 ; ModuleDefaults[i].name != NULL ; i++) {
+            if (strcmp(ModuleDefaults[i].name, "xmir") == 0) {
+                ModuleDefaults[i].toLoad = TRUE;
+            }
+        }
+    }
+
     if (xf86configptr->conf_modules) {
         /* Walk the disable list and let people know what we've parsed to
          * not be loaded 
diff --git a/hw/xfree86/common/xf86Events.c b/hw/xfree86/common/xf86Events.c
index 7a949fd..4d416b4 100644
--- a/hw/xfree86/common/xf86Events.c
+++ b/hw/xfree86/common/xf86Events.c
@@ -105,8 +105,6 @@ extern fd_set EnabledDevices;
 extern void (*xf86OSPMClose) (void);
 #endif
 
-static void xf86VTSwitch(void);
-
 /*
  * Allow arbitrary drivers or other XFree86 code to register with our main
  * Wakeup handler.
@@ -410,7 +408,7 @@ xf86ReleaseKeys(DeviceIntPtr pDev)
  * xf86VTSwitch --
  *      Handle requests for switching the vt.
  */
-static void
+_X_EXPORT void
 xf86VTSwitch(void)
 {
     int i;
@@ -466,7 +464,7 @@ xf86VTSwitch(void)
 
         xf86AccessLeave();      /* We need this here, otherwise */
 
-        if (!xf86VTSwitchAway()) {
+        if (!xorgMir && !xf86VTSwitchAway()) {
             /*
              * switch failed
              */
@@ -522,7 +520,7 @@ xf86VTSwitch(void)
     }
     else {
         DebugF("xf86VTSwitch: Entering\n");
-        if (!xf86VTSwitchTo())
+        if (!xorgMir && !xf86VTSwitchTo())
             return;
 
 #ifdef XF86PM
diff --git a/hw/xfree86/common/xf86Globals.c b/hw/xfree86/common/xf86Globals.c
index 7df7a80..17ed7c6 100644
--- a/hw/xfree86/common/xf86Globals.c
+++ b/hw/xfree86/common/xf86Globals.c
@@ -204,3 +204,6 @@ Bool xf86VidModeAllowNonLocal = FALSE;
 #endif
 RootWinPropPtr *xf86RegisteredPropertiesTable = NULL;
 Bool xorgHWAccess = FALSE;
+Bool xorgMir = FALSE;
+const char *mirID = NULL;
+const char *mirSocket = NULL;
diff --git a/hw/xfree86/common/xf86Helper.c b/hw/xfree86/common/xf86Helper.c
index 721159d..d319e0c 100644
--- a/hw/xfree86/common/xf86Helper.c
+++ b/hw/xfree86/common/xf86Helper.c
@@ -100,7 +100,14 @@ xf86DeleteDriver(int drvIndex)
         if (xf86DriverList[drvIndex]->module)
             UnloadModule(xf86DriverList[drvIndex]->module);
         free(xf86DriverList[drvIndex]);
-        xf86DriverList[drvIndex] = NULL;
+
+        /* Compact xf86DriverList array, update xf86NumDrivers */
+        xf86NumDrivers--;
+        if(drvIndex != xf86NumDrivers)
+            memmove(xf86DriverList + drvIndex,
+                    xf86DriverList + drvIndex + 1,
+                    sizeof(DriverPtr) * (xf86NumDrivers - drvIndex));
+        xf86DriverList = realloc(xf86DriverList, xf86NumDrivers * sizeof(DriverPtr));
     }
 }
 
diff --git a/hw/xfree86/common/xf86Init.c b/hw/xfree86/common/xf86Init.c
index 91ec4c8..0508e8d 100644
--- a/hw/xfree86/common/xf86Init.c
+++ b/hw/xfree86/common/xf86Init.c
@@ -530,7 +530,7 @@ InitOutput(ScreenInfo * pScreenInfo, int argc, char **argv)
          * needed at this early stage.
          */
 
-        for (i = 0; i < xf86NumDrivers; i++) {
+        for (i = 0; i < xf86NumDrivers; ) {
             xorgHWFlags flags = HW_IO;
 
             if (xf86DriverList[i]->Identify != NULL)
@@ -541,11 +541,20 @@ InitOutput(ScreenInfo * pScreenInfo, int argc, char **argv)
                                               GET_REQUIRED_HW_INTERFACES,
                                               &flags);
 
+            if (xorgMir &&
+                (NEED_IO_ENABLED(flags) || !(flags & HW_SKIP_CONSOLE))) {
+                ErrorF("Driver needs flags %lu, incompatible with nested, deleting.\n", flags);
+                xf86DeleteDriver(i);
+                continue;
+            }
+
             if (NEED_IO_ENABLED(flags))
                 want_hw_access = TRUE;
 
             if (!(flags & HW_SKIP_CONSOLE))
                 xorgHWOpenConsole = TRUE;
+
+            i++;
         }
 
         if (xorgHWOpenConsole)
@@ -631,9 +640,13 @@ InitOutput(ScreenInfo * pScreenInfo, int argc, char **argv)
         }
 
         /* Remove (unload) drivers that are not required */
-        for (i = 0; i < xf86NumDrivers; i++)
-            if (xf86DriverList[i] && xf86DriverList[i]->refCount <= 0)
+        for (i = 0; i < xf86NumDrivers; )
+            if (xf86DriverList[i] &&
+		!xf86DriverHasEntities(xf86DriverList[i]) &&
+		xf86DriverList[i]->refCount <= 0)
                 xf86DeleteDriver(i);
+            else
+                i++;
 
         /*
          * At this stage we know how many screens there are.
@@ -1454,6 +1467,17 @@ ddxProcessArgument(int argc, char **argv, int i)
         xf86Info.ShareVTs = TRUE;
         return 1;
     }
+    if (!strcmp(argv[i], "-mir")) {
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        mirID = argv[++i];
+        xorgMir = TRUE;
+        return 2;
+    }
+    if (!strcmp(argv[i], "-mirSocket")) {
+        CHECK_FOR_REQUIRED_ARGUMENT();
+        mirSocket = argv[++i];
+        return 2;
+    }
 
     /* OS-specific processing */
     return xf86ProcessArgument(argc, argv, i);
@@ -1527,6 +1551,8 @@ ddxUseMsg(void)
     ErrorF
         ("-novtswitch            don't automatically switch VT at reset & exit\n");
     ErrorF("-sharevts              share VTs with another X server\n");
+    ErrorF
+        ("-mir MirID             run nested in a Mir compositor with app id MirID\n");
     /* OS-specific usage */
     xf86UseMsg();
     ErrorF("\n");
diff --git a/hw/xfree86/common/xf86Priv.h b/hw/xfree86/common/xf86Priv.h
index 58cfe0a..96372fa 100644
--- a/hw/xfree86/common/xf86Priv.h
+++ b/hw/xfree86/common/xf86Priv.h
@@ -91,6 +91,9 @@ extern _X_EXPORT int xf86NumScreens;
 extern _X_EXPORT const char *xf86VisualNames[];
 extern _X_EXPORT int xf86Verbose;       /* verbosity level */
 extern _X_EXPORT int xf86LogVerbose;    /* log file verbosity level */
+extern _X_EXPORT Bool xorgMir;
+extern _X_EXPORT const char *mirID;
+extern _X_EXPORT const char *mirSocket;
 
 extern _X_EXPORT RootWinPropPtr *xf86RegisteredPropertiesTable;
 
@@ -147,6 +150,9 @@ xf86HandlePMEvents(int fd, pointer data);
 extern _X_EXPORT int (*xf86PMGetEventFromOs) (int fd, pmEvent * events,
                                               int num);
 extern _X_EXPORT pmWait (*xf86PMConfirmEventToOs) (int fd, pmEvent event);
+extern _X_EXPORT void
+xf86VTSwitch(void);
+
 
 /* xf86Helper.c */
 extern _X_EXPORT void
diff --git a/hw/xfree86/ramdac/xf86Cursor.c b/hw/xfree86/ramdac/xf86Cursor.c
index 860704e..5277c94 100644
--- a/hw/xfree86/ramdac/xf86Cursor.c
+++ b/hw/xfree86/ramdac/xf86Cursor.c
@@ -58,7 +58,12 @@ xf86InitCursor(ScreenPtr pScreen, xf86CursorInfoPtr infoPtr)
     xf86CursorScreenPtr ScreenPriv;
     miPointerScreenPtr PointPriv;
 
-    if (!xf86InitHardwareCursor(pScreen, infoPtr))
+    infoPtr->pScrn = xf86ScreenToScrn(pScreen);
+    
+    /* If we can't create a hardware cursor don't bother initialising HW cursor support */
+    if (infoPtr->MaxWidth != 0 &&
+        infoPtr->MaxHeight != 0 &&
+        !xf86InitHardwareCursor(pScreen, infoPtr))
         return FALSE;
 
     if (!dixRegisterPrivateKey(&xf86CursorScreenKeyRec, PRIVATE_SCREEN, 0))
diff --git a/hw/xfree86/ramdac/xf86HWCurs.c b/hw/xfree86/ramdac/xf86HWCurs.c
index 197abff..399bfb9 100644
--- a/hw/xfree86/ramdac/xf86HWCurs.c
+++ b/hw/xfree86/ramdac/xf86HWCurs.c
@@ -114,8 +114,6 @@ xf86InitHardwareCursor(ScreenPtr pScreen, xf86CursorInfoPtr infoPtr)
         infoPtr->RealizeCursor = RealizeCursorInterleave0;
     }
 
-    infoPtr->pScrn = xf86ScreenToScrn(pScreen);
-
     return TRUE;
 }
 
diff --git a/hw/xfree86/xmir/Makefile.am b/hw/xfree86/xmir/Makefile.am
new file mode 100644
index 0000000..80715f8
--- /dev/null
+++ b/hw/xfree86/xmir/Makefile.am
@@ -0,0 +1,26 @@
+INCLUDES =					\
+	$(XORG_INCS)                            \
+        -I$(srcdir)/../ddc                      \
+        -I$(srcdir)/../ramdac                   \
+        -I$(srcdir)/../i2c                      \
+        -I$(srcdir)/../parser                   \
+        -I$(srcdir)/../modes
+
+libxmir_la_LTLIBRARIES = libxmir.la
+libxmir_la_CFLAGS = \
+	-DHAVE_XORG_CONFIG_H \
+	$(DRI_CFLAGS) \
+	$(DIX_CFLAGS) $(XORG_CFLAGS) $(LIBDRM_CFLAGS) \
+	$(XMIR_CFLAGS)
+
+libxmir_la_LDFLAGS = -module -avoid-version $(LIBDRM_LIBS) $(XMIR_LIBS)
+libxmir_ladir = $(moduledir)/extensions
+libxmir_la_SOURCES = \
+	xmir.c \
+	xmir-window.c \
+	xmir-output.c \
+	xmir-thread-proxy.c \
+	xmir.h \
+	xmir-private.h
+
+sdk_HEADERS = xmir.h
diff --git a/hw/xfree86/xmir/xmir-output.c b/hw/xfree86/xmir/xmir-output.c
new file mode 100644
index 0000000..41696b5
--- /dev/null
+++ b/hw/xfree86/xmir/xmir-output.c
@@ -0,0 +1,571 @@
+/*
+ * Copyright © 2012 Canonical, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Christopher James Halse Rogers (christopher.halse.rogers@canonical.com)
+ */
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <math.h>
+
+#include <xorg-config.h>
+#include "xmir.h"
+#include "xmir-private.h"
+#include "xf86Crtc.h"
+#include "xf86Priv.h"
+
+struct xmir_crtc {
+    xmir_screen             *xmir;
+    xmir_window             *root_fragment;
+    MirDisplayConfiguration *config;
+};
+
+static void
+crtc_dpms(xf86CrtcPtr drmmode_crtc, int mode)
+{
+}
+
+static void
+xmir_output_populate(xf86OutputPtr xf86output, MirDisplayOutput *output)
+{
+    /* We can always arbitrarily clone and output */
+    xf86output->possible_crtcs = 0xffffffff;
+    xf86output->possible_clones = 0xffffffff;
+
+    xf86output->driver_private = output;
+
+    xf86output->interlaceAllowed = FALSE;
+    xf86output->doubleScanAllowed = FALSE;
+    xf86output->mm_width = output->physical_width_mm;
+    xf86output->mm_height = output->physical_height_mm;
+    /* TODO: Subpixel order from Mir */
+    xf86output->subpixel_order = SubPixelUnknown;
+}
+
+static Bool
+xmir_mir_mode_matches(MirDisplayMode *mir_mode, DisplayModePtr X_mode)
+{
+    return (mir_mode->vertical_resolution == X_mode->VDisplay &&
+            mir_mode->horizontal_resolution == X_mode->HDisplay /*&&
+            fabs(mir_mode->refresh_rate - X_mode->VRefresh) < 0.01*/);
+}
+
+static Bool
+xmir_set_mode_for_output(MirDisplayOutput *output,
+                         DisplayModePtr mode)
+{
+    for (int i = 0; i < output->num_modes; i++) {
+        xf86Msg(X_INFO, "Checking against mode (%dx%d)\n",
+                output->modes[i].horizontal_resolution,
+                output->modes[i].vertical_resolution);
+        if (xmir_mir_mode_matches(&output->modes[i], mode)) {
+            output->current_mode = i;
+            output->used = 1;
+            xf86Msg(X_INFO, "Matched mode %d\n", i);
+            return TRUE;
+        }
+    }
+    return FALSE;
+}
+
+static uint32_t
+xmir_update_outputs_for_crtc(xf86CrtcPtr crtc, DisplayModePtr mode, int x, int y)
+{
+    xf86CrtcConfigPtr crtc_cfg = XF86_CRTC_CONFIG_PTR(crtc->scrn);
+    uint32_t representative_output_id = mir_display_output_id_invalid;
+
+    for (int i = 0; i < crtc_cfg->num_output; i++) {
+        /* If this output should be driven by our "CRTC", set its mode */
+        if (crtc_cfg->output[i]->crtc == crtc) {
+            MirDisplayOutput *output = crtc_cfg->output[i]->driver_private;
+            xmir_set_mode_for_output(output, mode);
+            output->position_x = x;
+            output->position_y = y;
+            representative_output_id = output->output_id;
+        }
+    }
+    return representative_output_id;
+}
+
+static void
+xmir_disable_unused_outputs(xf86CrtcPtr crtc)
+{
+    xf86CrtcConfigPtr crtc_cfg = XF86_CRTC_CONFIG_PTR(crtc->scrn);
+
+    for (int i = 0; i < crtc_cfg->num_output; i++)
+        /* If any outputs are no longer associated with a CRTC, disable them */
+        if (crtc_cfg->output[i]->crtc == NULL)
+            ((MirDisplayOutput*)crtc_cfg->output[i]->driver_private)->used = 0;
+}
+
+static void
+xmir_stupid_callback(MirSurface *surf, void *ctx)
+{
+}
+
+static void
+xmir_dump_config(MirDisplayConfiguration *config)
+{
+  for (int i = 0; i < config->num_outputs; i++)
+    {
+      xf86Msg(X_INFO, "Output %d (%s, %s) has mode %d (%d x %d @ %.2f), position (%d,%d)\n",
+	      config->outputs[i].output_id,
+	      config->outputs[i].connected ? "connected" : "disconnected",
+	      config->outputs[i].used ? "enabled" : "disabled",
+	      config->outputs[i].current_mode,
+          config->outputs[i].used ? config->outputs[i].modes[config->outputs[i].current_mode].horizontal_resolution : 0,
+          config->outputs[i].used ? config->outputs[i].modes[config->outputs[i].current_mode].vertical_resolution : 0,
+          config->outputs[i].used ? config->outputs[i].modes[config->outputs[i].current_mode].refresh_rate : 0,
+	      config->outputs[i].position_x,
+	      config->outputs[i].position_y);
+    }
+}
+
+static void
+xmir_update_config(xf86CrtcConfigPtr crtc_cfg)
+{
+    MirDisplayConfiguration *new_config;
+    struct xmir_crtc *xmir_crtc = crtc_cfg->crtc[0]->driver_private;
+
+    mir_display_config_destroy(xmir_crtc->config);
+
+    new_config = mir_connection_create_display_config(xmir_connection_get());
+    for (int i = 0; i < crtc_cfg->num_crtc; i++) {
+        xmir_crtc = crtc_cfg->crtc[i]->driver_private;
+        xmir_crtc-> config = new_config;
+    }
+
+    if (crtc_cfg->num_output != new_config->num_outputs)
+        FatalError("[xmir] New Mir config has different number of outputs?");
+
+    for (int i = 0; i < crtc_cfg->num_output ; i++) {
+        /* TODO: Ensure that the order actually matches up */
+        xmir_output_populate(crtc_cfg->output[i], new_config->outputs + i);
+    }
+}
+
+static void
+xmir_crtc_surface_created(MirSurface *surface, void *ctx)
+{
+    xf86CrtcPtr crtc = ctx;
+    struct xmir_crtc *xmir_crtc = crtc->driver_private;
+
+    if (xmir_crtc->root_fragment->surface != NULL)
+        mir_surface_release(xmir_crtc->root_fragment->surface, xmir_stupid_callback, NULL);
+
+    xmir_crtc->root_fragment->surface = surface;
+}
+
+static Bool
+xmir_crtc_set_mode_major(xf86CrtcPtr crtc, DisplayModePtr mode,
+                         Rotation rotation, int x, int y)
+{
+    MirSurfaceParameters params = {
+        .name = "Xorg",
+        .width = mode->HDisplay,
+        .height = mode->VDisplay,
+        .pixel_format = mir_pixel_format_xrgb_8888,
+        .buffer_usage = mir_buffer_usage_hardware,
+        .output_id = mir_display_output_id_invalid
+    };
+    BoxRec output_bounds = {
+        .x1 = x,
+        .y1 = y,
+        .x2 = x + mode->HDisplay,
+        .y2 = y + mode->VDisplay
+    };
+    struct xmir_crtc *xmir_crtc = crtc->driver_private;
+    uint32_t output_id = mir_display_output_id_invalid;
+    const char *error_msg;
+
+    if (mode->HDisplay == 0 || mode->VDisplay == 0)
+        return FALSE;    
+
+    xf86Msg(X_INFO, "Initial configuration:\n");
+    xmir_dump_config(xmir_crtc->config);
+
+    xf86Msg(X_INFO, "Setting mode to %dx%d (%.2f)", mode->HDisplay, mode->VDisplay, mode->VRefresh);
+    output_id = xmir_update_outputs_for_crtc(crtc, mode, x, y);
+    xmir_disable_unused_outputs(crtc);
+
+    xf86Msg(X_INFO, "Updated configuration:\n");
+
+    xmir_dump_config(xmir_crtc->config);
+    mir_wait_for(mir_connection_apply_display_config(xmir_connection_get(),
+                                                     xmir_crtc->config));
+    error_msg = mir_connection_get_error_message(xmir_connection_get());
+    if (*error_msg != '\0') {
+        xf86Msg(X_ERROR, "[xmir] Failed to set new display config: %s\n",
+                error_msg);
+        return FALSE;
+        /* TODO: Restore correct config cache */
+    }
+
+    xmir_update_config(XF86_CRTC_CONFIG_PTR(crtc->scrn));
+
+    xf86Msg(X_INFO, "Post-modeset config:\n");
+    xmir_dump_config(xmir_crtc->config);
+
+    if (output_id == mir_display_output_id_invalid) {
+      if (xmir_crtc->root_fragment->surface != NULL)
+        mir_wait_for(mir_surface_release(xmir_crtc->root_fragment->surface, xmir_stupid_callback, NULL));
+        xmir_crtc->root_fragment->surface = NULL;
+        return TRUE;
+    }
+
+    params.output_id = output_id;
+    xf86Msg(X_INFO, "Putting surface on output %d\n", output_id);
+    mir_wait_for(mir_connection_create_surface(xmir_connection_get(),
+					       &params,
+					       xmir_crtc_surface_created,
+					       crtc));
+    if (!mir_surface_is_valid(xmir_crtc->root_fragment->surface)) {
+        xf86Msg(X_ERROR,
+                "[xmir] Failed to create surface for %dx%d mode: %s\n",
+                mode->HDisplay, mode->VDisplay,
+                mir_surface_get_error_message(xmir_crtc->root_fragment->surface));
+        return FALSE;
+    }
+
+
+    /* During X server init this will be NULL.
+       This is fixed up in xmir_window_create */
+    xmir_crtc->root_fragment->win = xf86ScrnToScreen(crtc->scrn)->root;
+
+    RegionInit(&xmir_crtc->root_fragment->region, &output_bounds, 0);
+    xmir_crtc->root_fragment->has_free_buffer = TRUE;
+
+    return TRUE;
+}
+
+static void
+crtc_set_cursor_colors (xf86CrtcPtr crtc, int bg, int fg)
+{
+}
+
+static void
+crtc_set_cursor_position (xf86CrtcPtr crtc, int x, int y)
+{
+}
+
+static void
+crtc_show_cursor (xf86CrtcPtr crtc)
+{
+}
+
+static void
+crtc_hide_cursor (xf86CrtcPtr crtc)
+{
+}
+
+static void
+crtc_load_cursor_argb (xf86CrtcPtr crtc, CARD32 *image)
+{
+}
+
+static PixmapPtr
+crtc_shadow_create(xf86CrtcPtr crtc, void *data, int width, int height)
+{
+    return NULL;
+}
+
+static void *
+crtc_shadow_allocate(xf86CrtcPtr crtc, int width, int height)
+{
+    return NULL;
+}
+
+static void
+crtc_shadow_destroy(xf86CrtcPtr crtc, PixmapPtr rotate_pixmap, void *data)
+{
+}
+
+static void
+xmir_crtc_destroy(xf86CrtcPtr crtc)
+{
+    struct xmir_crtc *xmir_crtc = crtc->driver_private;
+
+    if (xmir_crtc->root_fragment->surface != NULL)
+        mir_surface_release(xmir_crtc->root_fragment->surface, NULL, NULL);
+
+    free(xmir_crtc);
+}
+
+static const xf86CrtcFuncsRec crtc_funcs = {
+    .dpms                = crtc_dpms,
+    .set_mode_major      = xmir_crtc_set_mode_major,
+    .set_cursor_colors   = crtc_set_cursor_colors,
+    .set_cursor_position = crtc_set_cursor_position,
+    .show_cursor         = crtc_show_cursor,
+    .hide_cursor         = crtc_hide_cursor,
+    .load_cursor_argb    = crtc_load_cursor_argb,
+    .shadow_create       = crtc_shadow_create,
+    .shadow_allocate     = crtc_shadow_allocate,
+    .shadow_destroy      = crtc_shadow_destroy,
+    .destroy             = xmir_crtc_destroy,
+};
+
+static void
+xmir_output_dpms(xf86OutputPtr output, int mode)
+{
+    return;
+}
+
+static xf86OutputStatus
+xmir_output_detect(xf86OutputPtr output)
+{
+    MirDisplayOutput *mir_output = output->driver_private;
+    return mir_output->connected ? XF86OutputStatusConnected : XF86OutputStatusDisconnected;
+}
+
+static Bool
+xmir_output_mode_valid(xf86OutputPtr output, DisplayModePtr pModes)
+{
+    return MODE_OK;
+}
+
+static DisplayModePtr
+xmir_output_get_modes(xf86OutputPtr xf86output)
+{
+    MirDisplayOutput *mir_output = xf86output->driver_private;
+    DisplayModePtr modes = NULL, mode = NULL;
+
+    for (int i = 0; i < mir_output->num_modes; i++) {
+        /* Check if mode differs only by refresh rate from previous mode and reject */
+        /* TODO: Remove this check and instead handle refresh rate correctly */
+        if (mode != NULL)
+            if (xmir_mir_mode_matches((mir_output->modes + i), mode))
+                continue;
+
+        char *mode_name = malloc(32);
+        mode = xf86CVTMode(mir_output->modes[i].horizontal_resolution,
+                           mir_output->modes[i].vertical_resolution,
+                           60.0f,
+                           FALSE, FALSE);
+        /* And now, because the CVT standard doesn't support such common resolutions as 1366x768... */
+        mode->VDisplay = mir_output->modes[i].vertical_resolution;
+        mode->HDisplay = mir_output->modes[i].horizontal_resolution;
+
+        mode->type = M_T_DRIVER;
+        /* TODO: Get preferred mode from Mir, or get a guarantee that the first mode is preferred */
+        if (i == 0)
+            mode->type |= M_T_PREFERRED;
+
+        snprintf(mode_name, 32, "%dx%d", mode->HDisplay, mode->VDisplay);
+        mode->name = mode_name;
+        modes = xf86ModesAdd(modes, mode);
+    }
+    /* TODO: Get Mir to send us the EDID blob and add that */
+
+    return modes;
+}
+
+static void
+xmir_output_destroy(xf86OutputPtr xf86output)
+{
+    /* The MirDisplayOutput* in driver_private gets cleaned up by 
+       mir_display_config_destroy() */
+}
+
+static const xf86OutputFuncsRec xmir_output_funcs = {
+    .dpms       = xmir_output_dpms,
+    .detect     = xmir_output_detect,
+    .mode_valid = xmir_output_mode_valid,
+    .get_modes  = xmir_output_get_modes,
+    .destroy    = xmir_output_destroy
+};
+
+
+struct xmir_visit_set_pixmap_window {
+    PixmapPtr old, new;
+};
+
+static int
+xmir_visit_set_window_pixmap(WindowPtr window, pointer data)
+{
+    struct xmir_visit_set_pixmap_window *visit = data;
+
+    if (window->drawable.pScreen->GetWindowPixmap(window) == visit->old) {
+        window->drawable.pScreen->SetWindowPixmap(window, visit->new);
+        return WT_WALKCHILDREN;
+    }
+
+    return WT_DONTWALKCHILDREN;
+}
+
+static void
+xmir_set_screen_pixmap(PixmapPtr old_front, PixmapPtr new_front)
+{
+    struct xmir_visit_set_pixmap_window visit = {
+        .old = old_front,
+        .new = new_front
+    };
+    (old_front->drawable.pScreen->SetScreenPixmap)(new_front);
+
+    TraverseTree(old_front->drawable.pScreen->root, &xmir_visit_set_window_pixmap, &visit);
+}
+
+static Bool
+xmir_resize(ScrnInfoPtr scrn, int width, int height)
+{
+    xf86CrtcConfigPtr crtc_cfg = XF86_CRTC_CONFIG_PTR(scrn);
+    ScreenPtr screen = xf86ScrnToScreen(scrn);
+    PixmapPtr old_screen_pixmap, new_screen_pixmap;
+
+    if (scrn->virtualX == width && scrn->virtualY == height)
+        return TRUE;
+
+    old_screen_pixmap = screen->GetScreenPixmap(screen);
+    new_screen_pixmap = screen->CreatePixmap(screen, width, height, scrn->depth,
+                                             CREATE_PIXMAP_USAGE_BACKING_PIXMAP);
+
+    if (!new_screen_pixmap)
+        return FALSE;
+
+    scrn->virtualX = width;
+    scrn->virtualY = height;
+    scrn->displayWidth = width;
+
+    for (int i = 0; i < crtc_cfg->num_crtc; i++) {
+        xf86CrtcPtr crtc = crtc_cfg->crtc[i];
+
+        if (!crtc->enabled)
+            continue;
+
+        xmir_crtc_set_mode_major(crtc, &crtc->mode,
+                                 crtc->rotation, crtc->x, crtc->y);
+    }
+
+    xmir_set_screen_pixmap(old_screen_pixmap, new_screen_pixmap);
+    screen->DestroyPixmap(old_screen_pixmap);
+
+    xf86_reload_cursors(screen);
+
+    return TRUE;
+}
+
+static const xf86CrtcConfigFuncsRec config_funcs = {
+    xmir_resize
+};
+
+static void
+xmir_handle_hotplug(void *ctx)
+{
+    ScrnInfoPtr scrn = *(ScrnInfoPtr *)ctx;
+    xf86CrtcConfigPtr crtc_config = XF86_CRTC_CONFIG_PTR(scrn);
+
+    if (crtc_config->num_crtc == 0)
+        FatalError("[xmir] Received hotplug event, but have no CRTCs?\n");
+
+    xmir_update_config(crtc_config);
+
+    /* Trigger RANDR refresh */
+    RRGetInfo(xf86ScrnToScreen(scrn), TRUE);   
+}
+
+static void
+xmir_display_config_callback(MirConnection *unused, void *ctx)
+{
+    xmir_screen *xmir = ctx;
+
+    xmir_post_to_eventloop(xmir->hotplug_event_handler, &xmir->scrn);
+}
+
+Bool
+xmir_mode_pre_init(ScrnInfoPtr scrn, xmir_screen *xmir)
+{
+    int i;
+    MirDisplayConfiguration *display_config;
+    xf86CrtcPtr xf86crtc;
+
+    /* Set up CRTC config functions */
+    xf86CrtcConfigInit(scrn, &config_funcs);
+
+    /* We don't scanout of a single surface, so we don't have a scanout limit */
+    xf86CrtcSetSizeRange(scrn,
+                         320, 320,
+                         INT16_MAX, INT16_MAX);
+
+    /* Hook up hotplug notification */
+    xmir->hotplug_event_handler =
+        xmir_register_handler(&xmir_handle_hotplug,
+                              sizeof (ScreenPtr));
+
+    mir_connection_set_display_config_change_callback(
+        xmir_connection_get(),
+        &xmir_display_config_callback, xmir);
+
+    display_config =
+        mir_connection_create_display_config(xmir_connection_get());
+
+    xmir->root_window_fragments = malloc((display_config->num_outputs + 1) *
+                                         sizeof(xmir_window *));
+    xmir->root_window_fragments[display_config->num_outputs] = NULL;
+
+    if (xmir->root_window_fragments == NULL)
+        return FALSE;
+
+    for (i = 0; i < display_config->num_outputs; i++) {
+        xf86OutputPtr xf86output;
+        char name[32];
+
+        snprintf(name, sizeof name, "XMIR-%d", i);
+
+        xf86output = xf86OutputCreate(scrn, &xmir_output_funcs, name);
+
+        xmir_output_populate(xf86output, display_config->outputs + i);
+    }
+
+    /* TODO: Get the number of CRTCs from Mir */
+    for (i = 0; i < display_config->num_outputs; i++) {
+        struct xmir_crtc *xmir_crtc = malloc(sizeof *xmir_crtc);
+        if (xmir_crtc == NULL)
+            return FALSE;
+
+        xmir_crtc->xmir = xmir;
+        xmir_crtc->root_fragment = calloc(1, sizeof *xmir_crtc->root_fragment);
+        xmir_crtc->config = display_config;
+
+        if (xmir_crtc->root_fragment == NULL)
+            return FALSE;
+
+        xmir->root_window_fragments[i] = xmir_crtc->root_fragment;
+        RegionNull(&xmir_crtc->root_fragment->region);
+
+        xf86crtc = xf86CrtcCreate(scrn, &crtc_funcs);
+        xf86crtc->driver_private = xmir_crtc;
+    }
+
+    xf86SetScrnInfoModes(scrn);
+
+    /* TODO: Use initial Mir state rather than setting up our own */
+    xf86InitialConfiguration(scrn, TRUE);
+  
+    return TRUE;
+}
diff --git a/hw/xfree86/xmir/xmir-private.h b/hw/xfree86/xmir/xmir-private.h
new file mode 100644
index 0000000..9b144eb
--- /dev/null
+++ b/hw/xfree86/xmir/xmir-private.h
@@ -0,0 +1,107 @@
+/*
+ * Copyright © 2012 Canonical, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Christopher James Halse Rogers (christopher.halse.rogers@canonical.com)
+ */
+
+#ifndef _XMIR_PRIVATE_H
+#define _XMIR_PRIVATE_H
+
+#include <atomic_ops.h>
+#include <mir_toolkit/mir_client_library.h>
+#include "xmir.h"
+#include "xf86str.h"
+#include "list.h"
+#include "scrnintstr.h"
+#include "regionstr.h"
+
+#define MIR_MAX_BUFFER_AGE 3
+
+typedef struct xmir_marshall_handler xmir_marshall_handler;
+
+struct xmir_screen {
+    ScrnInfoPtr            scrn;
+    CreateWindowProcPtr    CreateWindow;
+    DestroyWindowProcPtr   DestroyWindow;
+    xmir_driver *          driver;
+    xmir_marshall_handler *submit_rendering_handler;
+    xmir_marshall_handler *hotplug_event_handler;
+    xmir_marshall_handler *focus_event_handler;
+    AO_t                   focus_count;
+    struct xorg_list       damage_list;
+    struct xmir_window   **root_window_fragments; /* NULL terminated array of xmir_window * */
+};
+
+struct xmir_window {
+    WindowPtr           win;
+    MirSurface         *surface;
+    RegionRec           region;
+    RegionRec           past_damage[MIR_MAX_BUFFER_AGE];
+    DamagePtr           damage;
+    int                 damage_index;
+    struct xorg_list    link_damage;
+    unsigned int        has_free_buffer:1;
+    unsigned int        damaged:1;
+};
+
+MirConnection *
+xmir_connection_get(void);
+
+xmir_screen *
+xmir_screen_get(ScreenPtr screen);
+
+xmir_window *
+xmir_window_get(WindowPtr win);
+
+void
+xmir_window_enable_damage_tracking(xmir_window *xmir_win);
+
+void
+xmir_window_disable_damage_tracking(xmir_window *xmir_win);
+
+
+Bool
+xmir_screen_init_window(ScreenPtr screen, xmir_screen *xmir);
+
+Bool
+xmir_mode_pre_init(ScrnInfoPtr scrn, xmir_screen *xmir);
+
+void
+xmir_init_thread_to_eventloop(void);
+
+xmir_marshall_handler *
+xmir_register_handler(void (*msg_handler)(void *msg), size_t msg_size);
+
+void
+xmir_post_to_eventloop(xmir_marshall_handler *handler, void *msg);
+
+void
+xmir_process_from_eventloop(void);
+
+ #endif /* _MIR_PRIVATE_H */
diff --git a/hw/xfree86/xmir/xmir-thread-proxy.c b/hw/xfree86/xmir/xmir-thread-proxy.c
new file mode 100644
index 0000000..7464644
--- /dev/null
+++ b/hw/xfree86/xmir/xmir-thread-proxy.c
@@ -0,0 +1,117 @@
+/*
+ * Copyright © 2012 Canonical, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Christopher James Halse Rogers (christopher.halse.rogers@canonical.com)
+ */
+
+#include <stdint.h>
+#include <string.h>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include "xmir-private.h"
+
+struct xmir_marshall_handler {
+	void (*msg_handler)(void *msg);
+	size_t msg_size;
+	char msg[];
+};
+
+static int pipefds[2];
+
+static void
+xmir_wakeup_handler(pointer data, int err, pointer read_mask)
+{
+    if (err >= 0 && FD_ISSET(pipefds[0], (fd_set *)read_mask))
+        xmir_process_from_eventloop();
+}
+
+void
+xmir_init_thread_to_eventloop(void)
+{
+	pipe(pipefds);
+
+	/* Set the read end to not block; we'll pull from this in the event loop
+	 * We don't need to care about the write end, as that'll be written to
+	 * from its own thread
+	 */
+	fcntl(pipefds[0], F_SETFL, O_NONBLOCK);
+
+	AddGeneralSocket(pipefds[0]);
+	RegisterBlockAndWakeupHandlers((BlockHandlerProcPtr)NoopDDA,
+				       xmir_wakeup_handler,
+				       NULL);
+}
+
+xmir_marshall_handler *
+xmir_register_handler(void (*msg_handler)(void *msg), size_t msg_size)
+{
+	xmir_marshall_handler *handler;
+
+	if (msg_size + sizeof *handler > PIPE_BUF)
+		return NULL;
+
+	handler = malloc(sizeof *handler + msg_size);
+	if (!handler)
+		return NULL;
+
+	handler->msg_handler = msg_handler;
+	handler->msg_size = msg_size;
+	return handler;
+}
+
+void
+xmir_post_to_eventloop(xmir_marshall_handler *handler, void *msg) 
+{
+	const int total_size = sizeof *handler + handler->msg_size;
+	/* We require the total size to be less than PIPE_BUF to ensure an atomic write */
+	assert(total_size < PIPE_BUF);
+
+	memcpy(handler->msg, msg, handler->msg_size);
+	write(pipefds[1], handler, total_size);
+}
+
+void
+xmir_process_from_eventloop(void)
+{
+	xmir_marshall_handler handler;
+	void *msg;
+
+	for (;;) {
+		if (read(pipefds[0], &handler, sizeof handler) < 0) {
+			return;
+		}
+
+		msg = malloc(handler.msg_size);
+		if(read(pipefds[0], msg, handler.msg_size) == handler.msg_size)
+			(*handler.msg_handler)(msg);
+		free(msg);
+	}
+}
+
diff --git a/hw/xfree86/xmir/xmir-window.c b/hw/xfree86/xmir/xmir-window.c
new file mode 100644
index 0000000..89c5448
--- /dev/null
+++ b/hw/xfree86/xmir/xmir-window.c
@@ -0,0 +1,340 @@
+/*
+ * Copyright © 2012 Canonical, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Christopher James Halse Rogers (christopher.halse.rogers@canonical.com)
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include "xorg-config.h"
+#endif
+#include <xorg-server.h>
+#include "windowstr.h"
+#include "regionstr.h"
+#include "damagestr.h"
+
+#include "xmir.h"
+#include "xmir-private.h"
+
+#include "xf86.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+
+static DevPrivateKeyRec xmir_window_private_key;
+static const RegionRec xmir_empty_region = { {0, 0, 0, 0}, &RegionBrokenData };
+
+xmir_window *
+xmir_window_get(WindowPtr win)
+{
+    /* The root window is handled specially */
+    assert(win->parent != NULL);
+
+    return dixGetPrivate(&win->devPrivates, &xmir_window_private_key);
+}
+
+_X_EXPORT int
+xmir_window_get_fd(xmir_window *xmir_win)
+{
+    MirBufferPackage *package;
+
+    if (mir_platform_type_gbm != mir_surface_get_platform_type(xmir_win->surface))
+        FatalError("[xmir] Only supported on DRM Mir platform\n");
+
+    mir_surface_get_current_buffer(xmir_win->surface, &package);
+    if (package->fd_items != 1)
+        FatalError("[xmir] Unexpected buffer contents from Mir; this is a programming error\n");
+
+    return package->fd[0];
+}
+
+static void
+xmir_handle_buffer_available(void *ctx)
+{
+    xmir_window *mir_win = *(xmir_window **)ctx;
+
+    if (mir_win->surface == NULL)
+        return;
+
+    xmir_screen *xmir =
+        xmir_screen_get(xmir_window_to_windowptr(mir_win)->drawable.pScreen);
+
+    mir_win->has_free_buffer = TRUE;
+    mir_win->damage_index = (mir_win->damage_index + 1) % MIR_MAX_BUFFER_AGE;
+
+    if (xmir_window_is_dirty(mir_win))
+        (*xmir->driver->BufferAvailableForWindow)(mir_win,
+                                                  xmir_window_get_dirty(mir_win));
+}
+
+static inline int
+index_in_damage_buffer(int current_index, int age)
+{
+    int index = (current_index - age) % MIR_MAX_BUFFER_AGE;
+
+    return index < 0 ? MIR_MAX_BUFFER_AGE + index : index;
+}
+
+static void
+handle_buffer_received(MirSurface *surf, void *ctx)
+{
+    xmir_window *xmir_win = ctx;
+
+    xmir_screen *xmir =
+        xmir_screen_get(xmir_window_to_windowptr(xmir_win)->drawable.pScreen);
+
+    xmir_post_to_eventloop(xmir->submit_rendering_handler, &xmir_win);
+}
+
+static RegionPtr
+damage_region_for_current_buffer(xmir_window *xmir_win)
+{
+    MirBufferPackage *package;
+    RegionPtr region;
+    int age;
+
+    mir_surface_get_current_buffer(xmir_win->surface, &package);
+    age = package->age;
+
+    region = &xmir_win->past_damage[index_in_damage_buffer(xmir_win->damage_index, age)];
+
+    /* As per EGL_EXT_buffer_age, contents are undefined for age == 0 */
+    if (age == 0)
+        RegionCopy(region, &xmir_win->region);
+
+    return region;
+}
+
+/* Submit rendering for @window to Mir
+ * @region is an (optional) damage region, to hint the compositor as to what
+ * region has changed. It can be NULL to indicate the whole window should be
+ * considered dirty.
+ */
+_X_EXPORT int
+xmir_submit_rendering_for_window(xmir_window *xmir_win,
+                                 RegionPtr region)
+{
+    RegionPtr tracking;
+
+    xmir_win->has_free_buffer = FALSE;
+    mir_surface_swap_buffers(xmir_win->surface, &handle_buffer_received, xmir_win);
+    tracking = damage_region_for_current_buffer(xmir_win);
+
+    if (region == NULL)
+        RegionEmpty(tracking);
+    else
+        RegionSubtract(tracking, tracking, region);
+
+    if (RegionNil(tracking))
+        xorg_list_del(&xmir_win->link_damage);
+
+    return Success;
+}
+
+_X_EXPORT Bool
+xmir_window_has_free_buffer(xmir_window *xmir_win)
+{
+    return xmir_win->has_free_buffer;
+}
+
+_X_EXPORT RegionPtr
+xmir_window_get_dirty(xmir_window *xmir_win)
+{
+    if (xorg_list_is_empty(&xmir_win->link_damage))
+        return (RegionPtr)&xmir_empty_region;
+
+    if (xmir_win->damaged) {
+        RegionPtr damage = DamageRegion(xmir_win->damage);
+        RegionIntersect(damage, damage, &xmir_win->region);
+        int i;
+
+        for (i = 0; i < MIR_MAX_BUFFER_AGE; i++) {
+            RegionUnion(&xmir_win->past_damage[i],
+                        &xmir_win->past_damage[i],
+                        damage);
+        }
+
+        DamageEmpty(xmir_win->damage);
+        xmir_win->damaged = 0;
+    }
+
+    return damage_region_for_current_buffer(xmir_win);
+}
+
+_X_EXPORT Bool
+xmir_window_is_dirty(xmir_window *xmir_win)
+{
+    return RegionNotEmpty(xmir_window_get_dirty(xmir_win));
+}
+
+_X_EXPORT WindowPtr
+xmir_window_to_windowptr(xmir_window *xmir_win)
+{
+    return xmir_win->win;
+}
+
+_X_EXPORT BoxPtr
+xmir_window_get_drawable_region(xmir_window *xmir_win)
+{
+    return RegionExtents(&xmir_win->region);
+}
+
+_X_EXPORT int32_t
+xmir_window_get_stride(xmir_window *xmir_win)
+{
+    MirBufferPackage *package;
+
+    mir_surface_get_current_buffer(xmir_win->surface, &package);
+
+    return package->stride;
+}
+
+static void
+damage_report(DamagePtr damage, RegionPtr region, void *ctx)
+{
+    xmir_window *xmir_win = ctx;
+
+    xmir_win->damaged = 1;
+    xorg_list_move(&xmir_win->link_damage,
+                   &xmir_screen_get(damage->pScreen)->damage_list);
+}
+
+static void
+damage_destroy(DamagePtr damage, void *ctx)
+{
+    xmir_window *xmir_win = ctx;
+    xorg_list_del(&xmir_win->link_damage);
+}
+
+void
+xmir_window_enable_damage_tracking(xmir_window *xmir_win)
+{
+    WindowPtr win = xmir_win->win;
+
+    if (xmir_win->damage != NULL)
+        return;
+
+    xorg_list_init(&xmir_win->link_damage);
+    xmir_win->damage = DamageCreate(damage_report, damage_destroy,
+                                    DamageReportNonEmpty, TRUE,
+                                    win->drawable.pScreen, xmir_win);
+    DamageRegister(&win->drawable, xmir_win->damage);
+
+    for (int i = 0; i < MIR_MAX_BUFFER_AGE; i++) {
+        RegionNull(&xmir_win->past_damage[i]);
+    }
+    xmir_win->damage_index = 0;
+    xmir_win->damaged = 0;
+}
+
+void
+xmir_window_disable_damage_tracking(xmir_window *xmir_win)
+{
+    if (xmir_win->damage != NULL) {
+        DamageUnregister(&xmir_win->win->drawable, xmir_win->damage);
+        DamageDestroy(xmir_win->damage);
+        xmir_win->damage = NULL;
+    }
+}
+
+static Bool
+xmir_create_window(WindowPtr win)
+{
+    ScreenPtr screen = win->drawable.pScreen;
+    xmir_screen *xmir = xmir_screen_get(screen);
+    Bool ret;
+
+    screen->CreateWindow = xmir->CreateWindow;
+    ret = (*screen->CreateWindow)(win);
+    screen->CreateWindow = xmir_create_window;
+
+    /* Until we support rootless operation, we care only for the root
+     * window, which has no parent.
+     */
+    if (win->parent == NULL) {
+        /* The CRTC setup has already created the root_window_fragments
+           array. We need to hook the root window into it */
+        for (int i = 0; xmir->root_window_fragments[i] != NULL; i++) {
+            xmir->root_window_fragments[i]->win = win;
+
+            /* TODO: This creates one Damage tracker per fragment; we only
+               really need one, though */
+            xmir_window_enable_damage_tracking(xmir->root_window_fragments[i]);
+        }
+    }
+    return ret;
+}
+
+static Bool
+xmir_destroy_window(WindowPtr win)
+{
+    ScreenPtr screen = win->drawable.pScreen;
+    xmir_screen *xmir = xmir_screen_get(screen);
+    Bool ret;
+
+    screen->DestroyWindow = xmir->DestroyWindow;
+    ret = (*screen->DestroyWindow)(win);
+    screen->DestroyWindow = xmir_destroy_window;
+
+    /* Until we support rootless operation, we care only for the root
+     * window, which has no parent.
+     */
+    if (win->parent == NULL) {
+        /* Break the link with the root_window_fragments */
+        for (int i = 0; xmir->root_window_fragments[i] != NULL; i++) {
+            xmir->root_window_fragments[i]->win = NULL;
+
+            /* We cannot use xmir_window_disable_damage_tracking here because
+             * the Damage extension will also clean it up on window destruction
+            */
+            xorg_list_del(&xmir->root_window_fragments[i]->link_damage);
+        }
+    }
+
+    return ret;
+}
+
+Bool
+xmir_screen_init_window(ScreenPtr screen, xmir_screen *xmir)
+{
+    if (!dixRegisterPrivateKey(&xmir_window_private_key, PRIVATE_WINDOW, 0))
+        return FALSE;
+
+    xmir->CreateWindow = screen->CreateWindow;
+    screen->CreateWindow = xmir_create_window;
+    xmir->DestroyWindow = screen->DestroyWindow;
+    screen->DestroyWindow = xmir_destroy_window;
+
+    xmir->submit_rendering_handler = 
+        xmir_register_handler(&xmir_handle_buffer_available,
+                              sizeof (xmir_window *));
+    if (xmir->submit_rendering_handler == NULL)
+        return FALSE;
+
+    return TRUE;
+}
diff --git a/hw/xfree86/xmir/xmir.c b/hw/xfree86/xmir/xmir.c
new file mode 100644
index 0000000..a294793
--- /dev/null
+++ b/hw/xfree86/xmir/xmir.c
@@ -0,0 +1,267 @@
+/*
+ * Copyright © 2012 Canonical, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Christopher James Halse Rogers (christopher.halse.rogers@canonical.com)
+ */
+
+#ifdef HAVE_XORG_CONFIG_H
+#include <xorg-config.h>
+#endif
+
+#include "xmir.h"
+#include "xmir-private.h"
+
+#include "list.h"
+#include "xf86.h"
+#include "xf86Crtc.h"
+#include "xf86Priv.h"
+
+#include <xf86drm.h>
+#include <string.h>
+
+#include <mir_toolkit/mir_client_library.h>
+#include <mir_toolkit/mir_client_library_drm.h>
+
+static DevPrivateKeyRec xmir_screen_private_key;
+/* 
+ * We have only a single Mir connection, regardless of how many
+ * drivers load.
+ */
+static MirConnection *conn;
+
+MirConnection *
+xmir_connection_get(void)
+{
+    return conn;
+}
+
+xmir_screen *
+xmir_screen_get(ScreenPtr screen)
+{
+    return dixGetPrivate(&screen->devPrivates, &xmir_screen_private_key);
+}
+
+_X_EXPORT int
+xmir_get_drm_fd(const char *busid)
+{
+    MirPlatformPackage platform;
+    int i, fd = -1;
+
+    mir_connection_get_platform(conn, &platform);
+
+    for (i = 0; i < platform.fd_items; ++i) {
+        char *fd_busid = drmGetBusid(platform.fd[i]);
+        if (!strcasecmp(busid, fd_busid))
+            fd = platform.fd[i];
+        drmFreeBusid(fd_busid);
+    }
+    return fd;
+}
+
+static void
+handle_auth_magic(int status, void *ctx)
+{
+    int *retVal = ctx;
+    *retVal = status;
+}
+
+_X_EXPORT int
+xmir_auth_drm_magic(xmir_screen *xmir, uint32_t magic)
+{
+    int status;
+    mir_wait_for(mir_connection_drm_auth_magic(xmir_connection_get(),
+                                               magic,
+                                               &handle_auth_magic,
+                                               &status));
+    return status;
+}
+
+_X_EXPORT xmir_screen *
+xmir_screen_create(ScrnInfoPtr scrn)
+{
+    xmir_screen *xmir = calloc (1, sizeof *xmir);
+    if (xmir == NULL)
+        return NULL;
+
+    xmir->scrn = scrn;
+
+    return xmir;
+}
+
+_X_EXPORT Bool
+xmir_screen_pre_init(ScrnInfoPtr scrn, xmir_screen *xmir, xmir_driver *driver)
+{
+    xmir->driver = driver;
+    xorg_list_init(&xmir->damage_list);
+
+    if (!xmir_mode_pre_init(scrn, xmir))
+        return FALSE;
+
+    return TRUE;
+}
+
+static void xmir_handle_focus_event(void *ctx)
+{
+    Bool new_focus = *(Bool *)ctx;
+    xf86Msg(X_INFO, "[XMir] Handling focus event, new_focus = %s\n", new_focus ? "TRUE" : "FALSE");
+
+    /* TODO: Split xf86VTSwitch out so that we don't need to check xf86VTOwner*/
+    /* TODO: Disable input on startup until we receive a usc ACK */
+    if (new_focus && !xf86VTOwner())
+        xf86VTSwitch();
+
+    if (!new_focus && xf86VTOwner())
+        xf86VTSwitch();
+}
+
+static void xmir_handle_lifecycle_event(MirConnection *unused, MirLifecycleState state, void *ctx)
+{
+    (void)unused;
+    xmir_screen *xmir = ctx;
+    Bool new_focus;
+    switch(state)
+    {
+    case mir_lifecycle_state_will_suspend:
+        new_focus = FALSE;
+        break;
+    case mir_lifecycle_state_resumed:
+        new_focus = TRUE;
+        break;
+    default:
+        xf86Msg(X_ERROR, "Received unknown Mir lifetime event\n");
+        return;
+    }
+    xmir_post_to_eventloop(xmir->focus_event_handler, &new_focus);
+}
+
+_X_EXPORT Bool
+xmir_screen_init(ScreenPtr screen, xmir_screen *xmir)
+{
+    if (!dixRegisterPrivateKey(&xmir_screen_private_key, PRIVATE_SCREEN, 0))
+        return FALSE;
+    dixSetPrivate(&screen->devPrivates, &xmir_screen_private_key, xmir);
+
+    if (!xmir_screen_init_window(screen, xmir))
+        return FALSE;
+
+    if (!xf86_cursors_init(screen, 0,0,0))
+        xf86Msg(X_WARNING, "xf86Cursor initialisation failed\n");
+
+    /* Hook up focus -> VT switch proxy */
+    xmir->focus_event_handler = 
+        xmir_register_handler(&xmir_handle_focus_event,
+                              sizeof(Bool));
+    if (xmir->focus_event_handler == NULL)
+        return FALSE;
+
+    mir_connection_set_lifecycle_event_callback(xmir_connection_get(),
+                                                &xmir_handle_lifecycle_event,
+                                                xmir);
+
+    return TRUE;
+}
+
+_X_EXPORT void
+xmir_screen_close(ScreenPtr screen, xmir_screen *xmir)
+{
+
+}
+
+_X_EXPORT void
+xmir_screen_destroy(xmir_screen *xmir)
+{
+    
+}
+
+_X_EXPORT void
+xmir_screen_for_each_damaged_window(xmir_screen *xmir, xmir_window_proc callback)
+{
+    xmir_window *xmir_win, *tmp_win;
+    xorg_list_for_each_entry_safe(xmir_win, tmp_win, &xmir->damage_list, link_damage) {
+        if (xmir_window_has_free_buffer(xmir_win) &&
+            xmir_window_is_dirty(xmir_win))
+            (*callback)(xmir_win, xmir_window_get_dirty(xmir_win));
+    }
+}
+
+static MODULESETUPPROTO(xMirSetup);
+static MODULETEARDOWNPROTO(xMirTeardown);
+
+static XF86ModuleVersionInfo VersRec = {
+    "xmir",
+    MODULEVENDORSTRING,
+    MODINFOSTRING1,
+    MODINFOSTRING2,
+    XORG_VERSION_CURRENT,
+    1, 0, 0,
+    ABI_CLASS_EXTENSION,
+    ABI_EXTENSION_VERSION,
+    MOD_CLASS_NONE,
+    {0, 0, 0, 0}
+};
+
+_X_EXPORT XF86ModuleData xmirModuleData = { &VersRec, xMirSetup, xMirTeardown };
+
+static pointer
+xMirSetup(pointer module, pointer opts, int *errmaj, int *errmin)
+{
+    static Bool setupDone = FALSE;
+    const char *socket = "/tmp/mir_socket";
+    
+    if (setupDone) {
+        if (errmaj)
+            *errmaj = LDR_ONCEONLY;
+        return NULL;
+    }
+
+
+    if (mirSocket != NULL)
+        socket = mirSocket;
+
+    conn = mir_connect_sync(socket, mirID);
+
+    if (!mir_connection_is_valid(conn)) {
+        if (errmaj)
+            *errmaj = LDR_MODSPECIFIC;
+        FatalError("Failed to connect to Mir: %s\n",
+                   mir_connection_get_error_message(conn));
+        return NULL;
+    }
+
+    xmir_init_thread_to_eventloop();    
+
+    setupDone = TRUE;
+
+    return module;
+}
+
+static void
+xMirTeardown(pointer module)
+{
+}
diff --git a/hw/xfree86/xmir/xmir.h b/hw/xfree86/xmir/xmir.h
new file mode 100644
index 0000000..78396a3
--- /dev/null
+++ b/hw/xfree86/xmir/xmir.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright © 2012 Canonical, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Christopher James Halse Rogers (christopher.halse.rogers@canonical.com)
+ */
+
+#ifndef _XMIR_H
+#define _XMIR_H
+
+#include <stdint.h>
+#include <mir_toolkit/mir_client_library.h>
+
+#include "xf86str.h"
+#include "scrnintstr.h"
+#include "window.h"
+
+typedef struct xmir_screen xmir_screen;
+typedef struct xmir_window xmir_window;
+
+typedef void (*xmir_window_proc)(xmir_window *xmir_win, RegionPtr damaged_region);
+
+#define XMIR_DRIVER_VERSION 1
+typedef struct {
+    int version;
+    xmir_window_proc BufferAvailableForWindow;
+} xmir_driver;
+
+_X_EXPORT int
+xmir_get_drm_fd(const char *busid);
+
+_X_EXPORT int
+xmir_auth_drm_magic(xmir_screen *xmir, uint32_t magic);
+
+_X_EXPORT xmir_screen *
+xmir_screen_create(ScrnInfoPtr scrn);
+
+_X_EXPORT Bool
+xmir_screen_pre_init(ScrnInfoPtr scrn, xmir_screen *xmir, xmir_driver *driver);
+
+_X_EXPORT Bool
+xmir_screen_init(ScreenPtr screen, xmir_screen *xmir);
+
+_X_EXPORT void
+xmir_screen_close(ScreenPtr screen, xmir_screen *xmir);
+	
+_X_EXPORT void
+xmir_screen_destroy(xmir_screen *xmir);
+
+_X_EXPORT WindowPtr
+xmir_window_to_windowptr(xmir_window *xmir_win);
+
+_X_EXPORT int
+xmir_window_get_fd(xmir_window *xmir_win);
+
+_X_EXPORT int
+xmir_submit_rendering_for_window(xmir_window *xmir_win,
+                                 RegionPtr region);
+
+_X_EXPORT Bool
+xmir_window_has_free_buffer(xmir_window *xmir_win);
+
+_X_EXPORT RegionPtr
+xmir_window_get_dirty(xmir_window *xmir_win);
+
+_X_EXPORT Bool
+xmir_window_is_dirty(xmir_window *xmir_win);
+
+_X_EXPORT BoxPtr
+xmir_window_get_drawable_region(xmir_window *xmir_win);
+
+_X_EXPORT int32_t
+xmir_window_get_stride(xmir_window *xmir_win);
+
+_X_EXPORT void
+xmir_screen_for_each_damaged_window(xmir_screen *xmir, xmir_window_proc callback);
+
+#endif /* _XMIR_H */
diff --git a/include/list.h b/include/list.h
index 11de7c5..59f0233 100644
--- a/include/list.h
+++ b/include/list.h
@@ -184,6 +184,14 @@ __xorg_list_del(struct xorg_list *prev, struct xorg_list *next)
     prev->next = next;
 }
 
+static inline void
+xorg_list_move(struct xorg_list *entry, struct xorg_list *head)
+{
+    __xorg_list_del(entry->prev, entry->next);
+    __xorg_list_add(entry, head->prev, head);
+}
+
+
 /**
  * Remove the element from the list it is in. Using this function will reset
  * the pointers to/from this element so it is removed from the list. It does
diff --git a/include/xorg-server.h.in b/include/xorg-server.h.in
index 81935be..c9cd4e8 100644
--- a/include/xorg-server.h.in
+++ b/include/xorg-server.h.in
@@ -212,4 +212,7 @@
 #define _XSERVER64 1
 #endif
 
+/* Build XMIR nested server */
+#undef XMIR
+
 #endif /* _XORG_SERVER_H_ */
diff --git a/miext/damage/damage.c b/miext/damage/damage.c
index a98c20e..a1daebb 100644
--- a/miext/damage/damage.c
+++ b/miext/damage/damage.c
@@ -123,18 +123,14 @@ static void
 damageReportDamagePostRendering(DamagePtr pDamage, RegionPtr pOldDamage,
                                 RegionPtr pDamageRegion)
 {
-    BoxRec tmpBox;
-    RegionRec tmpRegion, newDamage;
-    Bool was_empty;
-
-    RegionUnion(&newDamage, pOldDamage, pDamageRegion);
-
     switch (pDamage->damageLevel) {
     case DamageReportRawRegion:
         (*pDamage->damageReportPostRendering) (pDamage, pDamageRegion,
                                                pDamage->closure);
         break;
     case DamageReportDeltaRegion:
+    {
+        RegionRec tmpRegion;
         RegionNull(&tmpRegion);
         RegionSubtract(&tmpRegion, pDamageRegion, pOldDamage);
         if (RegionNotEmpty(&tmpRegion)) {
@@ -143,25 +139,31 @@ damageReportDamagePostRendering(DamagePtr pDamage, RegionPtr pOldDamage,
         }
         RegionUninit(&tmpRegion);
         break;
+    }
     case DamageReportBoundingBox:
+    {
+        BoxRec tmpBox;
+        RegionRec newDamage;
         tmpBox = *RegionExtents(pOldDamage);
+        RegionUnion(&newDamage, pOldDamage, pDamageRegion);
         if (!BOX_SAME(&tmpBox, RegionExtents(&newDamage))) {
             (*pDamage->damageReportPostRendering) (pDamage, &newDamage,
                                                    pDamage->closure);
         }
         break;
+    }
     case DamageReportNonEmpty:
-        was_empty = !RegionNotEmpty(pOldDamage);
-        if (was_empty && RegionNotEmpty(&newDamage)) {
-            (*pDamage->damageReportPostRendering) (pDamage, &newDamage,
+        if (RegionNotEmpty(pOldDamage))
+            break;
+
+        if (RegionNotEmpty(pDamageRegion)) {
+            (*pDamage->damageReportPostRendering) (pDamage, pDamageRegion,
                                                    pDamage->closure);
         }
         break;
     case DamageReportNone:
         break;
     }
-
-    RegionUninit(&newDamage);
 }
 
 #if DAMAGE_DEBUG_ENABLE
diff --git a/test/Makefile.am b/test/Makefile.am
index 34f53fc..d1a0f27 100644
--- a/test/Makefile.am
+++ b/test/Makefile.am
@@ -6,7 +6,12 @@ if XORG
 # For now, requires xf86 ddx, could be adjusted to use another
 SUBDIRS += xi2
 noinst_PROGRAMS += xkb input xtest misc fixes xfree86 hashtabletest os signal-logging
-endif
+
+if XMIR
+noinst_PROGRAMS += xmir-thread-proxy
+endif #XMIR
+
+endif #XORG
 check_LTLIBRARIES = libxservertest.la
 
 TESTS=$(noinst_PROGRAMS)
@@ -38,6 +43,8 @@ touch_LDADD=$(TEST_LDADD)
 signal_logging_LDADD=$(TEST_LDADD)
 hashtabletest_LDADD=$(TEST_LDADD) $(top_srcdir)/Xext/hashtable.c
 os_LDADD=$(TEST_LDADD)
+xmir_thread_proxy_LDADD=$(TEST_LDADD) $(top_srcdir)/hw/xfree86/xmir/xmir-thread-proxy.c -lpthread
+xmir_thread_proxy_CFLAGS=$(AM_CFLAGS) $(XMIR_CFLAGS) -I$(top_srcdir)/hw/xfree86/xmir -I$(top_srcdir)/hw/xfree86/common
 
 libxservertest_la_LIBADD = $(XSERVER_LIBS)
 if XORG
diff --git a/test/xmir-thread-proxy.c b/test/xmir-thread-proxy.c
new file mode 100644
index 0000000..7cf19cf
--- /dev/null
+++ b/test/xmir-thread-proxy.c
@@ -0,0 +1,154 @@
+/*
+ * Copyright © 2012 Canonical, Inc
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Soft-
+ * ware"), to deal in the Software without restriction, including without
+ * limitation the rights to use, copy, modify, merge, publish, distribute,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, provided that the above copyright
+ * notice(s) and this permission notice appear in all copies of the Soft-
+ * ware and that both the above copyright notice(s) and this permission
+ * notice appear in supporting documentation.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABIL-
+ * ITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF THIRD PARTY
+ * RIGHTS. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR HOLDERS INCLUDED IN
+ * THIS NOTICE BE LIABLE FOR ANY CLAIM, OR ANY SPECIAL INDIRECT OR CONSE-
+ * QUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE,
+ * DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
+ * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFOR-
+ * MANCE OF THIS SOFTWARE.
+ *
+ * Except as contained in this notice, the name of a copyright holder shall
+ * not be used in advertising or otherwise to promote the sale, use or
+ * other dealings in this Software without prior written authorization of
+ * the copyright holder.
+ *
+ * Authors:
+ *   Christopher James Halse Rogers (christopher.halse.rogers@canonical.com)
+ */
+
+#ifdef HAVE_DIX_CONFIG_H
+#include <dix-config.h>
+#endif
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <unistd.h>
+
+#include "xmir-private.h"
+
+struct test_content {
+	int *variable;
+	int value;
+};
+
+static void
+_test_callback(void *msg_content)
+{
+	struct test_content *content = msg_content;
+	*content->variable = content->value;
+}
+
+static void
+xmir_test_marshall_to_eventloop(void)
+{
+	xmir_marshall_handler *test_marshaller;
+	struct test_content msg;
+	int check = 0;
+
+	xmir_init_thread_to_eventloop();
+
+	test_marshaller = xmir_register_handler(&_test_callback, sizeof msg);
+
+	msg.variable = &check;
+	msg.value = 1;
+
+	xmir_post_to_eventloop(test_marshaller, &msg);
+	xmir_process_from_eventloop();
+
+	assert(check == 1);
+}
+
+static void
+_racy_test_callback(void *msg_content)
+{
+	struct test_content *content = msg_content;
+	int new_value = *content->variable + 1;
+	/* Ensure the other threads get to run and see the old value of content->variable */
+	usleep(100);
+	*content->variable = new_value;
+}
+
+struct thread_context {
+	xmir_marshall_handler *marshaller;
+	struct test_content *msg;
+};
+
+static void *
+_post_racy_msg(void *thread_ctx)
+{
+	struct thread_context *ctx = thread_ctx;
+
+	xmir_post_to_eventloop(ctx->marshaller, ctx->msg);
+
+	return NULL;
+}
+
+#define NUM_THREADS 10
+
+static void
+xmir_test_many_threads_to_eventloop(void)
+{
+	pthread_t threads[NUM_THREADS];
+	pthread_attr_t attr;
+	xmir_marshall_handler *test_marshaller;
+	struct thread_context ctx;
+	struct test_content msg;
+	int check = 0, i;
+
+	pthread_attr_init(&attr);
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);
+
+	xmir_init_thread_to_eventloop();
+
+	test_marshaller = xmir_register_handler(&_racy_test_callback, sizeof msg);
+
+	msg.variable = &check;
+
+	ctx.marshaller = test_marshaller;
+	ctx.msg = &msg;
+
+	for (i = 0; i < NUM_THREADS; i++) {
+		pthread_create(&threads[i], &attr, _post_racy_msg, (void *)&ctx);
+	}
+
+	pthread_attr_destroy(&attr);
+
+	for (i = 0; i < NUM_THREADS; i++) {
+		pthread_join(threads[i], NULL);
+	}
+
+	xmir_process_from_eventloop();
+
+	assert(check == NUM_THREADS);	
+}
+
+static void
+xmir_test_refuses_to_marshall_too_large_msg(void)
+{
+	xmir_init_thread_to_eventloop();
+
+	assert(xmir_register_handler(&_test_callback, PIPE_BUF) == NULL);
+}
+
+int
+main(int argc, char **argv)
+{
+	xmir_test_marshall_to_eventloop();
+	xmir_test_many_threads_to_eventloop();
+	xmir_test_refuses_to_marshall_too_large_msg();
+}
